//DarkAlertLevel2 version 2.0.0
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.DarkAlert = factory());
})(this, function () {
  'use strict';

  // SVG Icons
  const ICONS = {
    success: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>`,

    info: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
    </svg>`,

    warning: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
    </svg>`,

    error: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>`,

   loading: `<svg xmlns="http://www.w3.org/2000/svg" class="animate-spin" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1.5" />
  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" />
</svg>`,

    close: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="18" height="18">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>`
  };

  // Default options
  const DEFAULT_OPTIONS = {
    title: '',
    text: '',
    icon: 'info', // 'success', 'info', 'warning', 'error', 'loading'
    showConfirmButton: true,
    showCancelButton: false,
    confirmButtonText: 'OK',
    cancelButtonText: 'Cancel',
    confirmCallback: null,
    cancelCallback: null,
    closeOnOverlayClick: true,
    progress: true,
    timer: null, // ms
    position: 'center', // 'center', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end'
    animation: true,
    customClass: '',
    allowOutsideClick: true,
    backdrop: true,
    toast: false,
    toastPosition: 'bottom-end'
  };

  // Helper function to create elements with classes and attributes
  function createElement(tag, classes = [], attributes = {}) {
    const element = document.createElement(tag);

    if (classes.length) {
      element.classList.add(...classes);
    }

    Object.entries(attributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });

    return element;
  }

  // Main DarkAlert class
  class DarkAlert {
    constructor(options = {}) {
      this.options = { ...DEFAULT_OPTIONS, ...options };
      this.overlayElement = null;
      this.alertElement = null;
      this.timer = null;
      this.toastElement = null;

      // Initialize if not a toast
      if (!this.options.toast) {
        this.init();
      }
    }

    init() {
      // Create overlay
      this.overlayElement = createElement('div', ['dark-alert-overlay']);

      if (!this.options.backdrop) {
        this.overlayElement.style.background = 'transparent';
      }

      // Create alert container
      this.alertElement = createElement('div', ['dark-alert', `dark-alert-${this.options.icon}`]);

      if (this.options.customClass) {
        this.alertElement.classList.add(this.options.customClass);
      }

      // Build alert content
      this.buildAlertContent();

      // Append to overlay
      this.overlayElement.appendChild(this.alertElement);

      // Add to DOM
      document.body.appendChild(this.overlayElement);

      // Activate
      setTimeout(() => {
        this.overlayElement.classList.add('active');
      }, 10);

      // Setup event listeners
      this.setupEventListeners();

      // Handle timer if set
      this.handleTimer();

      // Prevent body scrolling
      document.body.style.overflow = 'hidden';

      return this;
    }

    buildAlertContent() {
      // Icon
      if (this.options.icon) {
        const iconContainer = createElement('div', ['dark-alert-icon']);
        iconContainer.innerHTML = ICONS[this.options.icon];
        this.alertElement.appendChild(iconContainer);
      }

      // Title
      if (this.options.title) {
        const title = createElement('h3', ['dark-alert-title']);
        title.textContent = this.options.title;
        this.alertElement.appendChild(title);
      }

      // Content
      if (this.options.text) {
        const content = createElement('div', ['dark-alert-content']);
        content.textContent = this.options.text;
        this.alertElement.appendChild(content);
      }

      // Buttons
      if (this.options.showConfirmButton || this.options.showCancelButton) {
        const buttonsContainer = createElement('div', ['dark-alert-buttons']);

        // Cancel button
        if (this.options.showCancelButton) {
          const cancelButton = createElement('button', ['dark-alert-button', 'dark-alert-button-cancel']);
          cancelButton.textContent = this.options.cancelButtonText;
          cancelButton.addEventListener('click', () => {
            this.close();
            if (typeof this.options.cancelCallback === 'function') {
              this.options.cancelCallback();
            }
          });
          buttonsContainer.appendChild(cancelButton);
        }

        // Confirm button
        if (this.options.showConfirmButton) {
          const confirmButton = createElement('button', ['dark-alert-button', 'dark-alert-button-confirm']);
          confirmButton.textContent = this.options.confirmButtonText;
          confirmButton.addEventListener('click', () => {
            this.close();
            if (typeof this.options.confirmCallback === 'function') {
              this.options.confirmCallback();
            }
          });
          buttonsContainer.appendChild(confirmButton);
        }

        this.alertElement.appendChild(buttonsContainer);
      }
	

  // Progress Bar
  if (this.options.timer && this.options.progress) {
    const progressContainer = createElement('div', ['dark-alert-progress']);
    const progressBar = createElement('div', ['dark-alert-progress-bar']);
    
    progressBar.style.animationDuration = `${this.options.timer}ms`;
    progressContainer.appendChild(progressBar);
    this.alertElement.appendChild(progressContainer);
  }
	
    }

    setupEventListeners() {
      // Close on overlay click if enabled
      if (this.options.closeOnOverlayClick && this.options.allowOutsideClick) {
        this.overlayElement.addEventListener('click', (e) => {
          if (e.target === this.overlayElement) {
            this.close();
          }
        });
      }

      // Close on ESC key
      document.addEventListener('keydown', this.escKeyHandler = (e) => {
        if (e.key === 'Escape' && this.options.allowOutsideClick) {
          this.close();
        }
      });
    }

    handleTimer() {
      if (this.options.timer && typeof this.options.timer === 'number') {
        this.timer = setTimeout(() => {
          this.close();
        }, this.options.timer);
      }
    }

    close() {
      if (this.overlayElement) {
        // Animate out
        this.overlayElement.classList.remove('active');

        // Clean up timer
        if (this.timer) {
          clearTimeout(this.timer);
        }

        // Remove from DOM after animation
        setTimeout(() => {
          document.body.removeChild(this.overlayElement);

          // Re-enable body scrolling if no other alerts are present
          if (!document.querySelector('.dark-alert-overlay')) {
            document.body.style.overflow = '';
          }

          // Remove event listeners
          document.removeEventListener('keydown', this.escKeyHandler);
        }, 300);
      }
    }

    // Toast methods
    static showToast(options) {
      const toastOptions = {
        ...options,
        toast: true,
        showConfirmButton: false,
        showCancelButton: false,
        timer: options.timer || 3000
      };

      const toast = new DarkAlert(toastOptions);
      return toast.createToast();
    }                                                         
    createToast() {
      // Create toast element
      this.toastElement = createElement('div', ['dark-alert-toast', `dark-alert-toast-${this.options.icon}`]);

      // Add custom class if provided
      if (this.options.customClass) {
        this.toastElement.classList.add(this.options.customClass);
      }

      // Icon
      const iconContainer = createElement('div', ['dark-alert-toast-icon']);
      iconContainer.innerHTML = ICONS[this.options.icon];
      this.toastElement.appendChild(iconContainer);

      // Content container
      const contentContainer = createElement('div', ['dark-alert-toast-content']);

      // Title
      if (this.options.title) {
        const title = createElement('div', ['dark-alert-toast-title']);
        title.textContent = this.options.title;
        contentContainer.appendChild(title);
      }
                                                                    // Message
      if (this.options.text) {
        const message = createElement('div', ['dark-alert-toast-message']);
        message.textContent = this.options.text;
        contentContainer.appendChild(message);
      }

      this.toastElement.appendChild(contentContainer);

      // Close button
      const closeButton = createElement('div', ['dark-alert-toast-close']);
      closeButton.innerHTML = ICONS.close;
      closeButton.addEventListener('click', () => this.closeToast());
      this.toastElement.appendChild(closeButton);

      // Progress bar for timer
      if (this.options.timer) {
        const progressBar = createElement('div', ['dark-alert-toast-progress']);
        this.toastElement.appendChild(progressBar);

        // Animate the progress bar
        setTimeout(() => {
          const innerBar = progressBar.querySelector('::before') || progressBar;
          innerBar.style.animation = `shrink ${this.options.timer / 1000}s linear forwards`;
        }, 10);
      }

      // Set position
      this.handleToastPosition();

      // Add to DOM
      document.body.appendChild(this.toastElement);

      // Activate
      setTimeout(() => {
        this.toastElement.classList.add('active');
      }, 10);

      // Handle timer
      if (this.options.timer) {
        this.timer = setTimeout(() => {
          this.closeToast();
        }, this.options.timer);
      }

      return this;
    }

    handleToastPosition() {
      const position = this.options.toastPosition || 'bottom-end';

      // Calculate position
      switch (position) {
        case 'top':
          this.toastElement.style.top = '24px';
          this.toastElement.style.left = '50%';
          this.toastElement.style.right = 'auto';
          this.toastElement.style.bottom = 'auto';
          this.toastElement.style.transform = 'translateX(-50%)';
          break;
        case 'top-start':
          this.toastElement.style.top = '24px';
          this.toastElement.style.left = '24px';
          this.toastElement.style.right = 'auto';
          this.toastElement.style.bottom = 'auto';
          break;
        case 'top-end':
          this.toastElement.style.top = '24px';
          this.toastElement.style.right = '24px';
          this.toastElement.style.left = 'auto';
          this.toastElement.style.bottom = 'auto';
          break;
        case 'bottom':
          this.toastElement.style.bottom = '24px';
          this.toastElement.style.left = '50%';
          this.toastElement.style.right = 'auto';
          this.toastElement.style.top = 'auto';
          this.toastElement.style.transform = 'translateX(-50%)';
          break;
        case 'bottom-start':
          this.toastElement.style.bottom = '24px';
          this.toastElement.style.left = '24px';
          this.toastElement.style.right = 'auto';
          this.toastElement.style.top = 'auto';
          break;
        case 'bottom-end':
        default:
          this.toastElement.style.bottom = '24px';
          this.toastElement.style.right = '24px';
          this.toastElement.style.left = 'auto';
          this.toastElement.style.top = 'auto';
          break;
      }
    }

    closeToast() {
      if (this.toastElement) {
        // Animate out
        this.toastElement.classList.remove('active');

        // Clear timer
        if (this.timer) {
          clearTimeout(this.timer);
        }

        // Remove from DOM after animation
        setTimeout(() => {
          if (this.toastElement.parentNode) {
            document.body.removeChild(this.toastElement);
          }
        }, 300);
      }
    }

    // Static methods for easy use
    static fire(options) {
      return new DarkAlert(options);
    }

    static success(options) {
      return new DarkAlert({ icon: 'success', ...options });
    }

    static info(options) {
      return new DarkAlert({ icon: 'info', ...options });
    }

    static warning(options) {
      return new DarkAlert({ icon: 'warning', ...options });
    }

    static error(options) {
      return new DarkAlert({ icon: 'error', ...options });
    }

    static loading(options) {
      return new DarkAlert({ icon: 'loading', ...options });
    }

    // Toast variants
    static successToast(options) {
      return DarkAlert.showToast({ icon: 'success', ...options });
    }

    static infoToast(options) {
      return DarkAlert.showToast({ icon: 'info', ...options });
    }

    static warningToast(options) {
      return DarkAlert.showToast({ icon: 'warning', ...options });
    }

    static errorToast(options) {
      return DarkAlert.showToast({ icon: 'error', ...options });
    }

    static loadingToast(options) {
      return DarkAlert.showToast({ icon: 'loading', ...options });
    }
  }

  // Initialize when DOM is ready
  if (typeof window !== 'undefined') {
    // Create the stylesheet link if not already added
    const linkId = 'darkalert';
    if (!document.getElementById(linkId)) {
      const link = document.createElement('link');
      link.id = linkId;
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/gh/general-04/DarkAlert@main/darkalertv2.min.css';
      document.head.appendChild(link);
    }
  }

  return DarkAlert;
});
